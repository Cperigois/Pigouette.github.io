var store = [,{
    "title": "Beyond the Lab",
    "excerpt":"Current projects                                                                                                                       Search for anomalies in Time Series                                                    Developpement of an autoencoder to detect anomalies such as drift in sinuso√Ødal signals.                                                   Learn more                                                                                                                                                    Palm oil farms searches                                                    Deep learning algorithm to detect palm oil farms from satellite images. Under developement                                                   Learn more                                                                                                                                                    Lectures for python beginners                                                    From python basics to a well built architecture                                                   Learn more                                        ","url": "http://localhost:4000/Cperigois.github.io/BeyondTheLab/"
  },{
    "title": "Noise modelisation and propagation in gravitational wave detector",
    "excerpt":"To detect gravitational waves with maximum efficiency, interferometers must be maintained at their operating point ‚Äî ideally on a dark fringe ‚Äî so that any deviation (from gravitational wave signals) creates detectable interference patterns at the photodiodes. This is achieved through multiple feedback control loops that stabilize the mirror positions and the input laser frequency.   However, these control systems can also serve as channels through which instrumental noise propagates within the detector. A significant part of my PhD work involved modeling these feedback loops to better understand how noise is introduced and transferred throughout the system.   Interferometer Degrees of Freedom   The longitudinal control of the interferometer is based on four main degrees of freedom (DoF), which represent critical optical lengths in the system. These are:           CARM (Common Arm):  \\(CARM = \\frac{L_N + L_W}{2}\\) Controls the average length of the Fabry-P√©rot arms using signal from photodiode B2.            DARM (Differential Arm):  \\(DARM = L_N - L_W\\) Key observable for gravitational waves, controlling the end mirror positions.            MICH (Michelson):  \\(MICH = l_N - l_W\\) Measures asymmetry in the short arms, extracted via photodiode B4.            PRCL (Power Recycling Cavity Length):  \\(PRCL = l_0 + \\frac{l_W + l_N}{2}\\) Coupled with MICH, also measured via B4, and used to stabilize the power recycling mirror (PRM).       These DoFs define the longitudinal control architecture.     Interferometer and Control Loop Modeling   The control loop simulation framework, called Noise Budget, includes all major subsystems:      Sensing (green): Converts photodiode signals into error signals for each DoF.   Mirror/Frequency Control (yellow): Converts errors into corrective signals.   Driving (orange): Simulates actual mirror actuation.   Laser (blue): Simulates laser frequency response.   Optickle (violet): Models optical response to all mirror and laser perturbations.   These modules together simulate the closed-loop noise propagation and are used to test new control strategies or predict future interferometer performance.     Study of the MICH Loop   The MICH control loop is responsible for stabilizing short-arm asymmetry.  For frequencies above 50 Hz, the loop is dominated by detection noise (electronic + shot noise).  Assuming this dominance, I was able to derive the injection transfer function ( Y(f) ) for the loop and validate the simulated model against actual interferometer data.  This confirmed the theoretical noise paths and highlighted where detection noise dominates the system.     Study of the SSFS Loop (Laser Frequency Stabilization)   The laser introduces phase noise, which is integrated from frequency fluctuations. Due to arm asymmetries (mirror reflectivity, thermal effects), this phase noise couples into the main gravitational wave signal channel.   The Second Stage Frequency Stabilization (SSFS) loop uses reflected optical signals at POP, measured via photodiode B4, to compute correction signals for the laser.   This loop is influenced by time-varying transfer functions due to thermal drifts and asymmetry fluctuations. To model this, I introduced time-dependent gains:      \\(F_{PC}(t)\\): Power Coupling Gain   \\(F_{TC}(t)\\): Transfer Coupling Gain   \\(Y(f, t)\\): Injection Transfer Function   These parameters were calibrated using broadband noise injections (( N_{inj} )) and validated at times ( t_{inj} ). The model was used to explain differences between simulated and real data in DARM.     Conclusion   The feedback control systems in the Virgo interferometer are essential for keeping the detector in its optimal operating state. By modeling the noise propagation through these loops, it‚Äôs possible to:      Identify dominant noise sources   Design more effective control strategies   Predict the sensitivity of future detectors   Through this work, I demonstrated that:      The MICH loop is dominated by detection noise above 50Hz.   The SSFS loop requires time-varying modeling due to asymmetries.   Overall, this project not only validated important theoretical models, but also highlighted remaining challenges, such as unexplained bias and underestimation of some residual noise sources.      Future work should investigate whether these mismatches originate from modeling assumptions, unmodeled loop couplings, or unknown noise mechanisms.    ","url": "http://localhost:4000/Cperigois.github.io/gravitational-waves/Noisebudget"
  },{
    "title": "Recherche d'anomalie dans une s√©rie temporelle",
    "excerpt":"               ¬†                       Cette √©tude s‚Äôincrit dans une curiosit√© de ma part sur l‚Äôimpl√©mentation d‚Äôauteencodeur pour detecteur des anomalies electoniques en analyse du signal. Ce type d‚Äô√©tue est d√©ja largement document√© sur paper with codes en voici quelques bonnes r√©f√©rences :   . Pour moi c‚Äôest l‚Äôoccasion de me form√© a un nouveau domaine du deep learning les autoencodeurs                 appliqu√©s aux s√©ries temporelles que je connais d√©ja bien.           L‚Äôobjectif de cette √©tude est de tater les limite de l‚Äôutilisation d‚Äôautoencodeurs dans la recherche d‚Äôanomalies dans les signaux temporels. La question etant tr√®s vaste je me suis limit√© ici aux signaux sinusoidaux affect√© par du bruit gaussien et un bruit de d√©rive typique de l‚Äôusure de composants electroniques. Pour ce billet je vous propose une petit r√©sum√© du fonctionnement des autoencodeurs, accompagn√© des parametres que j‚Äôai choisit pour cette √©tude. Dans unes second partie de detaillerai la strat√©gie d‚Äôentrainement ‚Äú√©tape par √©tape‚Äù qui permet de palier au probleme de p√©riodicit√© de la fonction sinus. Enfin dans la derniere partie le model sera mis √† l‚Äô√©preuve avec une √©valuation et des tests sur des donn√©es bruit√©es par un ratio de d√©rive.   Model IA   La base des autoencodeurs   ‚ÄúEcrit une introduction basique aux autoencodeurs‚Äù   Mon model   ‚ÄúVoila mon model : class CNNEncoder(nn.Module):     def init(self, encoded_size):         super(CNNEncoder, self).init()         self.encoder = nn.Sequential(             nn.Conv1d(1, 16, kernel_size=5, stride=2, padding=2),  # [B, 16, 250]             nn.ReLU(),             nn.Conv1d(16, 32, kernel_size=5, stride=2, padding=2),  # [B, 32, 125]             nn.ReLU(),             nn.Conv1d(32, 64, kernel_size=5, stride=2, padding=2),  # [B, 64, ~63]             nn.ReLU(),             nn.Flatten(),             nn.Linear(64 * 63, encoded_size)         )   def forward(self, x):     return self.encoder(x)   class CNNDecoder(nn.Module):     def init(self, encoded_size):         super(CNNDecoder, self).init()         self.decoder_input = nn.Linear(encoded_size, 64 * 63)         self.decoder = nn.Sequential(             nn.Unflatten(1, (64, 63)),             nn.ConvTranspose1d(64, 32, kernel_size=5, stride=2, padding=2, output_padding=1),  # [B, 32, ~125]             nn.ReLU(),             nn.ConvTranspose1d(32, 16, kernel_size=5, stride=2, padding=2, output_padding=1),  # [B, 16, ~250]             nn.ReLU(),             nn.ConvTranspose1d(16, 1, kernel_size=5, stride=2, padding=2, output_padding=1),   # [B, 1, ~500]         )   def forward(self, x):     x = self.decoder_input(x)     x = self.decoder(x)     return x   class CNNAutoencoder(nn.Module):     def init(self, encoded_size):         super(CNNAutoencoder, self).init()         self.encoder = CNNEncoder(encoded_size)         self.decoder = CNNDecoder(encoded_size)         self.encoded_size = encoded_size   def forward(self, x):     latent = self.encoder(x)     reconstructed = self.decoder(latent)     return reconstructed ecrit un court paragraphe pour le d√©crire \"   Entrainement du model   Les donn√©es d‚Äôentrainement   L‚Äôentrainement est r√©alis√© sur des sets de 12000 signaux de 500s, envoy√©s par patch de 32 au GPU.   La strat√©gie √©tape par √©tape   ‚ÄúL‚Äôentrainement du modele √© √©t√© r√©alis√© √©tape par √©tape, voici les diff√©rentes √©tapes et leurs caract√©ristique, il faudrait les repertorier dans un tableau. Etape 1 : La suniso√Øde pure, sur 10 epochs, amplitude 4, phase 0, fr√©quence 0.05Hz, bruit Aucun Etape 2 : L√©gere variation de l‚Äôamplitude, sur 30 epochs, amplitude Uniform(3.5,4.5), phase 0, fr√©quence 0.05Hz, bruit Aucun Etape 3 : Et l√©g√®re variation de la phase, sur 30 epochs, amplitude Uniform(3.5,4.5), phase Uniform(0,0.5), fr√©quence 0.05Hz, bruit Aucun Etape 4 : Et l√©g√®re variation de la fr√©quence, sur 100 epochs, amplitude Uniform(3.5,4.5), phase Uniform(0,0.5), fr√©quence Uniform(0.025,0.075)Hz, bruit Aucun Etape 5 : Et ajout d‚Äôun faible bruit gaussien, sur 100 epochs, amplitude Uniform(3.5,4.5), phase Uniform(0,0.5), fr√©quence Uniform(0.025,0.075)Hz, bruit Loi normale(mu = 0, std = 0.05) Etape 6 : Augmantation de la variation des parametre de la sinuso√Øde, sur 250 epochs, amplitude Uniform(2,6), phase Uniform(0,2pi), fr√©quence Uniform(0.025,0.225)Hz, bruit Loi normale(mu = 0, std = 0.05) Etape 7 : Augmantation du bruit gaussien, sur 400 epochs, amplitude Uniform(2,6), phase Uniform(0,2pi), fr√©quence Uniform(0.025,0.225)Hz, bruit Loi normale(mu = 0, std = 0.25) Chaque √©tape de l‚Äôentrainement d√©marre avec un learning rate assez √©lev√© de 1.e-4. Avec un scheduler, ReduceLROnPlateau, qui a chaque epoche verifie que l‚Äôentrainement d‚Äôai pas atteint un seuil qui l‚Äôempeche de progresser, et si c‚Äôest le cas diminue le mearning rate. ‚Äú   Le bruit r√©siduel   LEs signaux contenant du bruit gaussien il est impossible pour le modele de pr√©dire parfaitement le signal d‚Äôentr√©e. Il y a donc dans cette √©tude un bruit r√©siduel. Si l‚Äôon reprend la formule de notre fonction de perte cf eqation pr√©c√©dente, on peut y decomposer le signal target comme la somme d‚Äôun signal informatif et d‚Äôun bruit al√©atoire. En supposant que notre modele est parfait on a alors output = signal informatif. Il reste dons une erreur r√©siduelle :  mse = mean((output - (informativ_signal + random_noise)) ** 2) residual error = mean(random_noise ** 2) Dans le cas de notre √©tude le bruit r√©siduel sur la fonction de perte est de 0.0025 pour le bruit gaussien des √©tapes 4-6, puis de 0.0625 pour l‚Äô√©tape finale d‚Äôentrainement.   Ecrit une place pour que j‚Äôinsert ici un graphique ‚Äúsinuso√Ød_recognition.png‚Äù r√©pr√©sentant l‚Äô√©volution de la loss de validation pendant l‚Äôentrainement avec une l√©gende que je pourrait modifier.   Evaluation et test sur des donn√©es bruit√©es   Evaluation du model   Le model est √©valu√© sur 10000 nouveaux signaux g√©n√©r√©s comme a l‚Äô√©tape 7 de l‚Äôentrainement. On retrouve une valeur m√©diane de la perte de 0.078+0.053-0.012 ce qui est suffisament proche de l‚Äôerreur r√©siduelle pour notre cas d‚Äô√©tudes.   Les donn√©es bruit√©es  On mat notre model d‚Äôautoencodeur a l‚Äô√©preuve d‚Äôun bruit de d√©rive ‚Äúpetite definition d‚Äôun bruit de d√©rive et formula math√©matique ici‚Äù   Voici quelques exemple de signaux obtenus apres ajout du bruit de d√©rive pour quatra valeur diff√©rente ‚ÄúIci j‚Äôinsere une image avec 4 graphe repr√©sentant le signal avec sa composante d√©rive et sa reconstitution par le model‚Äù   Performance de d√©tection d‚Äôanomalie   Comme on l‚Äôattendait, le model n‚Äôarrive pas a reproduire le signal d‚Äôentr√©e si il y a un bruit suppl√©mentaire auquel il n‚Äôest pas entrain√©. Sur le graphique suivant j‚Äôai quantifi√© le score de perte de 1000 signaux pour 8 valeurs diff√©rentes de ratios de d√©rive. J‚Äôai choisit de placer trois zones de confiance, lors du calcul de la perte.  OK : lorsque la perte est inf√©rieur au 95 eme percentille de notre sample d‚Äô√©valuation, le signal est avec confiance consid√©r√© comme normal. WARNING : lorsque la perte est comprise entre le 95eme percentille de du sample d‚Äô√©valuation mais inf√©rieure a la valaur maximale obtenue dans l‚Äô√©valuation, le signal est consid√©r√© comme a risque, et la tendance doit etre surveill√©e. ANOMALY : au dela de la valeur maximale de perte obtenue dans le sample d‚Äô√©valuation le signal est consid√©r√© comme anormale et des investigations plus pouss√©es sont necessaires   Pour avoir une valeur comparable des r√©sultats avec d‚Äôautres problemes j‚Äôai √©valu√© le Noise ratio defini comme Noise ratio = total_drift/residual error avec total_drift la d√©rive totale du signal sur sa dur√©e. On constate que notre model detecte des anomalies de derive a partir de 1.6*bruit r√©siduel, ce qui est tr√®s performant. Ces performance pourraient etre encore augment√© en prenant des signaux plus long pour accentuer la d√©rive totale.   Conclusion   Les autoencodeurs sont efficace pour detecter des anomalies dans les signaux sinusoidaux bruit√©s avec un ratio de d√©rive l√©ger. Lorque ce ratio se rapprohe du bruit gaussien avec un Noise ratio &lt; 1.6, le bruit devient trop faible pour etre discern√© du bruit blanc sur  la dur√©e √©valu√©e ici 500 secondes.   Ouverture : faire des test sur des signaux plus long permet de mettre en √©vidente des ratio de d√©rive plus faible.  J‚Äôai affirm√© dans mon √©tude que le probleme rencontr√© a l‚Äôentrainement direct avec les donn√©es complexee provenait e la caract√©ristique sinusoidale du signale, qui automatiquement donne un signal moyen null. Cette affiramtion m√©rite une investigation plus large (peut etre une future √©tude),il sera possible d‚Äôajouter un offser, de travailler avec des fonctions de heavyside, ou encore des triangle. Ce cas reste un cas d‚Äô√©cole, prototyp√© avec des donn√©es construitent, il faudrait mettre cette strategie a l‚Äô√©preuve sur des donn√©es r√©elles.   ","url": "http://localhost:4000/Cperigois.github.io/IAlab/"
  },{
    "title": "Search for anomalies in sinusoidal signals",
    "excerpt":"               ¬†                       This study stems from a personal curiosity about the implementation of autoencoders for anomaly detection in signal processing. This type of approach is already widely documented on Papers With Code; here are a few relevant references. For me, it‚Äôs also an opportunity to get hands-on experience in a new area of deep learning: autoencoders applied to time series, a topic I already understand well from a signal analysis perspective.           The goal of this study is to test the limits of autoencoder-based anomaly detection in time-series signals. Given the breadth of the topic, I limited the study to sinusoidal signals affected by Gaussian noise and drift noise, the latter being typical of wear in electronic components.   This post consists of three sections:     A summary of how autoencoders work, with the parameters used in this study.   The ‚Äústep-by-step‚Äù training strategy to address the periodic nature of the signals.   A model evaluation on noisy signals with a controlled drift ratio.     AI Model   Basics of Autoencoders   An autoencoder is a type of neural network designed to reconstruct its input after compressing it into a lower-dimensional latent space. It has two parts:      The encoder: reduces the input dimensionality to extract its essential features.   The decoder: reconstructs the input from the compressed representation.   In unsupervised learning, an autoencoder can learn dominant patterns in the data. Any significant reconstruction error then indicates an anomaly (i.e., data that deviates from the learned patterns).   The standard loss function is the Mean Squared Error:   \\[\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\hat{x}_i)^2\\]  where \\(x_i\\) is the original data and \\(\\hat{x}_i\\) is its reconstruction.     My Model   The model used in this study is a 1D convolutional autoencoder designed for fixed-length time signals (500 samples). It consists of two main blocks: an encoder and a decoder, built from convolutional layers suited to time-structured data.   Encoder   The encoder transforms the input signal into a low-dimensional latent representation. It includes:   Three successive 1D convolutional layers with:      Increasing numbers of channels (16, 32, then 64),   A kernel size of 5,   A stride of 2 to progressively reduce temporal resolution,   A ReLU activation after each convolution.   The output is then flattened into a linear vector and passed through a fully connected layer to produce a latent embedding of predefined size (encoded_size).   Decoder   The decoder reconstructs the original signal from the latent representation. It mirrors the encoder:      A first fully connected layer reshapes the latent vector into a tensor suitable for the transposed convolutional layers.   Three transposed convolution layers:            They progressively increase the temporal resolution,       Reduce the number of channels from 64 ‚Üí 32 ‚Üí 16 ‚Üí 1 (the original shape),       Each step is followed by a ReLU activation, except the last.           This architecture allows the model to learn to extract key features from the input signal and reconstruct them as faithfully as possible. Latent compression forces the autoencoder to filter noise and retain only essential information.   This model encodes 500-sample input signals into a latent space sized at 30% of the input, and reconstructs them via transposed convolutions. The architecture is intentionally compact to facilitate progressive learning of simple patterns.     Model Training   Training Data   Training is conducted on batches of 12,000 signals, each 500 samples long, fed in mini-batches of 32 to the GPU. Each signal is a noisy sinusoid, randomly generated according to the parameters defined for each training phase.     Step-by-Step Training Strategy   Training progresses through increasingly complex signal generations. The summary table is as follows:                  Step       Epochs       Amplitude       Phase       Frequency (Hz)       Noise                       1       10       4       0       0.05       None                 2       30       \\(\\mathcal{U}(3.5, 4.5)\\)       0       0.05       None                 3       30       \\(\\mathcal{U}(3.5, 4.5)\\)       \\(\\mathcal{U}(0, 0.5)\\)       0.05       None                 4       100       \\(\\mathcal{U}(3.5, 4.5)\\)       \\(\\mathcal{U}(0, 0.5)\\)       \\(\\mathcal{U}(0.025, 0.075)\\)       None                 5       100       \\(\\mathcal{U}(3.5, 4.5)\\)       \\(\\mathcal{U}(0, 0.5)\\)       \\(\\mathcal{U}(0.025, 0.075)\\)       \\(\\mathcal{N}(0, 0.05)\\)                 6       250       \\(\\mathcal{U}(2, 6)\\)       \\(\\mathcal{U}(0, 2œÄ)\\)       \\(\\mathcal{U}(0.025, 0.225)\\)       \\(\\mathcal{N}(0, 0.05)\\)                 7       400       \\(\\mathcal{U}(2, 6)\\)       \\(\\mathcal{U}(0, 2œÄ)\\)       \\(\\mathcal{U}(0.025, 0.225)\\)       \\(\\mathcal{N}(0, 0.25)\\)           A ReduceLROnPlateau scheduler dynamically adjusts the learning rate from an initial value of ( 10^{-4} ), if validation loss plateaus.     Residual Noise   Due to the random nature of the added noise, perfect signal reconstruction is impossible. The final loss therefore stabilizes to a non-zero residual noise.   Assuming:   \\[\\text{signal}_{\\text{target}} = \\text{informative\\_signal} + \\text{random\\_noise}\\]  and perfect reconstruction of the informative part, the MSE becomes:   \\[\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n [(\\text{output} - \\text{target})^2] = \\frac{1}{n} \\sum_{i=1}^n [\\text{random\\_noise}^2]\\]  In this study:     Steps 4‚Äì6: residual noise ‚âà 0.0025   Step 7: residual noise ‚âà 0.0625      Blue : Validation loss evolution across the different training steps described on the previous table. Red : Learning rate evolution across the training. The grey zone represents the theoretical limits the model cannot overtake.     Evaluation and Testing on Noisy Signals   Model Evaluation   The model is evaluated on 10,000 new signals generated with the parameters of Step 7.  Observed median loss:   \\[\\text{MSE}_{\\text{test}} = 0.078^{+0.053}_{-0.012}\\]  This is compatible with residual noise, indicating good generalization capacity.     Drift Noise   A drift component was added to the signals:      Drift is a slow and continuous signal shift over time. It can be modeled with an affine function:    \\[\\text{drift}(t) = \\alpha \\cdot t\\]  where \\(\\alpha\\) is the drift coefficient.     Examples of drifted signals and their reconstruction for various values of \\(\\alpha\\).     Anomaly Detection   The model fails to reconstruct signals containing unseen drift, as expected. For each drift ratio, the loss is compared to evaluation percentiles:      OK: MSE &lt; 95·µó ∞ percentile   WARNING: 95·µó ∞ percentile &lt; MSE &lt; max   ANOMALY: MSE &gt; max (evaluation)   To quantify detection threshold, we define the noise ratio:   \\[\\text{Noise ratio} = \\frac{\\text{total\\_drift}}{\\text{residual\\_error}}\\]  The model detects anomalies as soon as the noise ratio reaches 1.6, which shows high sensitivity. This could be improved by increasing signal length.      Performance for drift signal reconstitution for various values of \\(\\alpha\\).     Conclusion   Autoencoders prove effective for detecting anomalies in sinusoidal signals contaminated by Gaussian noise and drift. The method is particularly sensitive to gradual deviations, as long as their amplitude exceeds the residual noise.   Next steps:     Use longer signals to detect subtler drift.   Explore other waveform types: triangular signals, Heaviside functions, etc.   Test the hypothesis that training difficulties stem from the zero-mean nature of sinusoids ‚Äî e.g., by adding an offset.   This project is a proof-of-concept on simulated data. It would be relevant to test this approach on real-world data to assess its industrial potential.    ","url": "http://localhost:4000/Cperigois.github.io/BeyondTheLab/AILab/Search_anomaly"
  },{
    "title": "Recherche d'anomalie dans une s√©rie temporelle",
    "excerpt":"               ¬†                       Cette √©tude s‚Äôinscrit dans une curiosit√© personnelle concernant l‚Äôimpl√©mentation d‚Äôautoencodeurs pour la d√©tection d‚Äôanomalies √©lectroniques en analyse du signal. Ce type d‚Äôapproche est d√©j√† largement document√© sur Papers With Code ; voici quelques r√©f√©rences pertinentes. Pour moi, c‚Äôest √©galement l‚Äôoccasion de me former √† un nouveau domaine du deep learning : les autoencodeurs appliqu√©s aux s√©ries temporelles, un sujet que je ma√Ætrise d√©j√† bien du point de vue signal.           L‚Äôobjectif de cette √©tude est de tester les limites de l‚Äôutilisation d‚Äôautoencodeurs dans la recherche d‚Äôanomalies dans les signaux temporels. Le sujet √©tant tr√®s vaste, je me suis limit√© ici √† l‚Äô√©tude de signaux sinuso√Ødaux affect√©s par un bruit gaussien et un bruit de d√©rive, ce dernier √©tant typique de l‚Äôusure de composants √©lectroniques.   Ce billet se compose de trois parties :     Un r√©sum√© du fonctionnement des autoencodeurs, avec les param√®tres choisis pour cette √©tude.   La strat√©gie d‚Äôentra√Ænement ¬´ √©tape par √©tape ¬ª pour contourner les difficult√©s li√©es √† la p√©riodicit√© des signaux.   Une √©valuation du mod√®le sur des donn√©es bruit√©es contenant un ratio de d√©rive contr√¥l√©.     Mod√®le IA   La base des autoencodeurs   Un autoencodeur est un type de r√©seau de neurones dont l‚Äôobjectif est de reconstruire l‚Äôentr√©e apr√®s l‚Äôavoir compress√©e dans un espace latent de plus faible dimension. Il se compose de deux parties :      L‚Äôencodeur : r√©duit la dimensionnalit√© de l‚Äôentr√©e pour extraire ses caract√©ristiques essentielles.   Le d√©codeur : reconstruit l‚Äôentr√©e √† partir de la repr√©sentation compress√©e.   En apprentissage non supervis√©, un autoencodeur peut ainsi apprendre les motifs dominants des donn√©es. Toute erreur de reconstruction importante indique alors une anomalie (c‚Äôest-√†-dire une donn√©e ne correspondant pas au motif appris).   La fonction de perte classique est l‚Äôerreur quadratique moyenne :   \\[\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\hat{x}_i)^2\\]  o√π ( x_i ) est la donn√©e originale et ( \\hat{x}_i ) sa reconstruction.     Mon mod√®le   Le mod√®le utilis√© dans cette √©tude est un autoencodeur convolutionnel 1D con√ßu pour traiter des signaux temporels de longueur fixe (500 √©chantillons). Il se compose de deux blocs principaux : un encodeur et un d√©codeur, construits √† partir de couches convolutives, adapt√©es aux donn√©es structur√©es dans le temps.   Encodeur   L‚Äôencodeur transforme le signal d‚Äôentr√©e en une repr√©sentation latente de dimension r√©duite (embedding). Il est constitu√© de :   Trois couches de convolution 1D successives avec :           Un nombre croissant de canaux (16, puis 32, puis 64),            Un noyau de convolution de taille 5,            Un stride de 2 pour r√©duire progressivement la r√©solution temporelle,            Une activation ReLU apr√®s chaque convolution.       √Ä la fin de ces couches, la sortie est applatie (flatten) pour former un vecteur lin√©aire, qui est ensuite projet√© via une couche lin√©aire (fully connected) vers l‚Äôespace latent de taille d√©finie (encoded_size).   D√©codeur   Le d√©codeur reconstruit le signal original √† partir de la repr√©sentation latente. Il r√©alise l‚Äôop√©ration inverse de l‚Äôencodeur, avec :   Une premi√®re couche lin√©aire pour transformer le vecteur latent en un tenseur compatible avec la structure attendue par les couches de d√©convolution.   Trois couches de convolution transpos√©e (aussi appel√©es ‚Äúd√©convolutions‚Äù) :   Elles augmentent progressivement la taille du signal dans le temps,   R√©duisent le nombre de canaux de 64 √† 32, puis 16, puis 1 (la forme du signal d‚Äôorigine),   Chaque √©tape est suivie d‚Äôune activation ReLU, sauf la derni√®re.   Ce design permet au mod√®le d‚Äôapprendre √† extraire les motifs caract√©ristiques du signal d‚Äôentr√©e, puis √† les reconstruire aussi fid√®lement que possible. La compression dans l‚Äôespace latent force l‚Äôautoencodeur √† filtrer le bruit et √† ne conserver que les informations essentielles.   Ce mod√®le encode des signaux d‚Äôentr√©e de taille 500 vers un espace latent de dimension fix√©e √† 30% de la taille d‚Äôentr√©e dans notre cas, avant de les reconstituer via des couches convolutionnelles transpos√©es. L‚Äôarchitecture est volontairement compacte pour faciliter l‚Äôapprentissage progressif de motifs simples.     Entra√Ænement du mod√®le   Les donn√©es d‚Äôentra√Ænement   L‚Äôentra√Ænement est r√©alis√© sur des lots de 12000 signaux de 500 secondes, envoy√©s par batchs de 32 au GPU. Chaque signal est une sinuso√Øde bruit√©e, g√©n√©r√©e al√©atoirement selon les param√®tres de l‚Äô√©tape d‚Äôapprentissage.     Strat√©gie d‚Äôapprentissage par √©tapes   L‚Äôentra√Ænement suit une progression par complexification croissante des signaux. Voici un r√©sum√© en tableau :                  √âtape       √âpoques       Amplitude       Phase       Fr√©quence       Bruit                       1       10       4       0       0.05 Hz       Aucun                 2       30       Uniform(3.5, 4.5)       0       0.05 Hz       Aucun                 3       30       Uniform(3.5, 4.5)       Uniform(0, 0.5)       0.05 Hz       Aucun                 4       100       Uniform(3.5, 4.5)       Uniform(0, 0.5)       Uniform(0.025, 0.075) Hz       Aucun                 5       100       Uniform(3.5, 4.5)       Uniform(0, 0.5)       Uniform(0.025, 0.075) Hz       Bruit gaussien ( \\mathcal{N}(0, 0.05) )                 6       250       Uniform(2, 6)       Uniform(0, 2œÄ)       Uniform(0.025, 0.225) Hz       Bruit gaussien ( \\mathcal{N}(0, 0.05) )                 7       400       Uniform(2, 6)       Uniform(0, 2œÄ)       Uniform(0.025, 0.225) Hz       Bruit gaussien ( \\mathcal{N}(0, 0.25) )           Un scheduler de type ReduceLROnPlateau est utilis√© pour ajuster dynamiquement le learning rate √† partir d‚Äôune valeur initiale de ( 10^{-4} ), en cas de stagnation des performances.     Le bruit r√©siduel   Le mod√®le ne peut reconstruire parfaitement le signal d‚Äôentr√©e, √† cause de la composante al√©atoire du bruit. La perte finale atteint donc une valeur non nulle, appel√©e bruit r√©siduel.   Consid√©rons :   \\[\\text{signal}_{\\text{target}} = \\text{signal}_{\\text{informatif}} + \\text{bruit}_{\\text{al√©atoire}}\\]  et supposons une reconstruction parfaite du signal informatif. Alors, l‚Äôerreur moyenne devient :   \\[\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n [(\\text{output} - \\text{signal}_{\\text{target}})^2] = \\frac{1}{n} \\sum_{i=1}^n [\\text{bruit}_{\\text{al√©atoire}}^2]\\]  Dans notre √©tude :     √âtapes 4‚Äì6 : bruit r√©siduel ‚âà 0.0025   √âtape 7 : bruit r√©siduel ‚âà 0.0625      √âvolution de la perte de validation durant l‚Äôentra√Ænement (l√©gende √† adapter).     √âvaluation et tests sur signaux bruit√©s   √âvaluation du mod√®le   Le mod√®le est √©valu√© sur 10‚ÄØ000 nouveaux signaux g√©n√©r√©s avec les param√®tres de l‚Äô√©tape 7.  La perte m√©diane observ√©e est :   \\[\\text{MSE}_{\\text{test}} = 0.078^{+0.053}_{-0.012}\\]  Ce qui reste compatible avec le bruit r√©siduel, indiquant un bon pouvoir de g√©n√©ralisation.     Les donn√©es bruit√©es   Un bruit de d√©rive a √©t√© ajout√© aux signaux :      Une d√©rive est une modification lente et continue du signal dans le temps. Elle peut √™tre mod√©lis√©e par une fonction affine :    \\[\\text{drift}(t) = \\alpha \\cdot t\\]  o√π ( \\alpha ) est le coefficient de d√©rive.      Exemples de signaux avec d√©rive pour quatre valeurs de ( \\alpha ), compar√©s √† leur reconstruction.     D√©tection d‚Äôanomalie   Le mod√®le √©choue √† reconstruire correctement les signaux contenant une d√©rive non apprise, comme attendu. Pour chaque ratio de d√©rive, la perte est compar√©e aux percentiles de l‚Äô√©valuation :      OK : MSE &lt; 95·µâ percentile   WARNING : 95·µâ percentile &lt; MSE &lt; max   ANOMALY : MSE &gt; max (√©valuation)   Pour quantifier le seuil de d√©tection, on d√©finit le noise ratio :   \\[\\text{Noise ratio} = \\frac{\\text{total\\_drift}}{\\text{erreur r√©siduelle}}\\]  Le mod√®le d√©tecte des anomalies d√®s que le noise ratio atteint 1.6, ce qui indique une tr√®s bonne sensibilit√©. Cette performance pourrait √™tre am√©lior√©e en augmentant la dur√©e des signaux.      Exemples de signaux avec d√©rive pour quatre valeurs de ( \\alpha ), compar√©s √† leur reconstruction.     Conclusion   Les autoencodeurs se montrent efficaces pour d√©tecter des anomalies dans des signaux sinuso√Ødaux contamin√©s par du bruit gaussien et de la d√©rive. La m√©thode est particuli√®rement sensible aux d√©viations progressives, tant que leur amplitude d√©passe le bruit r√©siduel.   Perspectives :     Travailler sur des signaux plus longs pour d√©tecter des d√©rives plus faibles.   Explorer des alternatives aux sinuso√Ødes : signaux triangulaires, fonctions de Heaviside, etc.   V√©rifier l‚Äôhypoth√®se selon laquelle les difficult√©s d‚Äôentra√Ænement proviennent de la moyenne nulle des sinuso√Ødes ‚Äî en ajoutant par exemple un offset.   Ce travail constitue un prototype sur donn√©es simul√©es. Il serait pertinent de valider cette approche sur des donn√©es r√©elles pour en mesurer le potentiel industriel.    ```  ","url": "http://localhost:4000/Cperigois.github.io/IAlab/"
  },{
    "title": "All projects",
    "excerpt":"A list of all projects presented on this website. Projects tagged as ‚Äúindependent‚Äù are self-initiated,  driven by curiosity, and developed as part of my self-learning journey.   My projects                                  Noise modelisation and propagation in gravitational wave detector                                       Statistics            Regression            Frequency- Spectrum            Time-Series            Matlab            Simulink            Modeling                                          Study and modelisation of noise propagation through control loops in the Virgo detector                                                                Search for anomalies in sinusoidal signals                                       Autoencodeur            CNN            Simulation            Time-Series            Python            PyTorch            Modeling                                          Proof of concept (PoC) demonstrating the efficiency of autoencoders for anomaly detection in time series signals.                                                                                                                                                             ","url": "http://localhost:4000/Cperigois.github.io/all-projects/"
  },{
    "title": {"en":"Black holes & gravitational waves","fr":"Trous noirs & ondes gravitationnelles"},
    "excerpt":"Pour introduire mes travaux de recherche je propose de les integrer dans trois pr√©sentations vulgaris√©es plus larges qui permettront d‚Äôevaluer le contexte g√©n√©ral des projets que j‚Äôai eu le plaisir de mener pendant ma carriere. Vous trouverez donc trois pages de recherche :      Les ondes gravitationnelles et leur d√©tections   Aux origines des trous noirs   ??   Sur cette premi√®re page j‚Äôintroduis les ondes gravitationnelles dns le but de pr√©senter mes travaux de recherches et les projets  auxquels j‚Äôai eu le plaisir de participer.   Une introduction historique  Les ondes gravitationnelles sont des perturbations de l‚Äôespace temps qui se propagent √† la vitesse de la lumi√®re. Elles  sont une cons√©quence directe de la theorie de la relativit√© g√©n√©rales d‚ÄôAlbert Einstein et des ses collaborateurs.ices  soumise en 1915, sous la forme de deux papiers principaux : ‚ÄúOn the general theory of relativity‚Äù  et ‚ÄúThe Field Equations of Gravitation‚Äù. La premi√®re publication  formalisant les ondes gravitationnelles ‚Äú√úber Gravitationswellen‚Äù  quant a elle arrive 3 ans plus tard.                                         Abstract de l‚Äôarticle original sur les ondes gravitationnelles en 1918 par Albert Einstein           En 1974, Rusell Hulse et Joseph Taylor, d√©couvrent le pulsar binaire PSR B1913+16, c‚Äôest a dire un syst√®me de deux objet  en orbite dont l‚Äôun est un pulsar, qui a intervalle r√©gulier √©met un pulse de lumi√®re. En 1979 apr√®s quatre ans de  surveillance des carat√©risiques du syst√®mes, Hulse et Taylor mettent en √©vidence que l‚Äô√©volution de l‚Äôorbite du systeme  reproduit parfaitement les pr√©dictions de la th√©orie de la gravitation pour un syst√®me binaire (Lien vers la publication. Cette d√©couverte leur apportera un prix nobel en 1993. La publication la plus r√©cente a ce jour (2016) qui r√©pertorie ces  mesures est en libre acces √† ce lien : Deni√®re publication de 2016                                         Graphique repr√©sentant la d√©croissance de la p√©riode du pulsar binaire. Les points rouges repr√©sentent les prises de donn√©es, avec leur incertitudes (quasi invisible car faibles). La courbe repr√©sente la pr√©diction de la th√©orie de la gravitation           C‚Äôest l‚Äôann√©e du centi√®me anniversaire de la th√©orie de la relativit√© g√©n√©rale, en 2015, que la premi√®re mesure directe  d‚Äôonde gravitationnelles √† eu lieu. Les d√©tecteurs am√©ricains LIGO d√©tecter alors la fusion de deux trous noirs de  respectivement 29 et 36 masses solaires (Lien vers l‚Äôarticle)   A partir de 2017,lors de la seconde phase de prise de donn√©es (O2), le d√©tecteur europ√©en rejoint le reseau am√©ricain, et permet la  traiangulation du signal pour reconstruire la provenance des sources d‚Äôondes gravitaionnelles. Le 17 aout 2017, le nouveau  r√©seau observe une fusion de deux √©toiles √† neutrons conjointement avec les ondes electromagn√©tiques  (Lien vers la publication,  Lien vers l‚Äôarticle de la d√©tection multimessag√®re. C‚Äôest la naissance  le l‚Äôastronomie multimessag√®re c‚Äôest √† dire la construction d‚Äôune communaut√© pluridisciplinaire, qui permet d‚Äôobserver les  ph√©nom√®nes astrophysiques avec diff√©rents messagers : les ondes electromagn√©tiques, les rayons cosmiques, les neutrinos et  les ondes gravitationnelles. C‚Äôest √©galement en 2017 que les travaux de la premi√®res d√©tections, GW150914, sont r√©compens√©s d‚Äôun prix nobel.   Au jour de l‚Äô√©criture de cette page (2025) le reseaux de d√©tecteurs d‚Äôondes gravitationnel compte 4 instruments, deux  sur le sol americain, un en italie, et un au Japon. La communaut√© d√©nombre desormais plus d‚Äôune centaine d‚Äôobservation de  fusions de trous noirs, offrant √† la communaut√© astrophysiques des donn√©es pr√©cieuses sur l‚Äôhistoire et l‚Äô√©volution de l‚Äôunivers.   Detecter les ondes gravitationnelles      Pr√©sentation √† la conf√©rence X  Paris, Mars 2022     ","url": "http://localhost:4000/Cperigois.github.io/fr/gravitational-waves/"
  },{
    "title": "Black Holes & Gravitational Waves",
    "excerpt":"To introduce my research work, I present it through three broader, popular-science-oriented sections. These allow a general contextualization of the scientific projects I have had the pleasure of conducting throughout my career. You will find three main topics:      Gravitational waves and their detection   The origin of black holes   (Upcoming content)   This first page is dedicated to gravitational waves, offering an overview of the field and introducing my related research projects.     A Brief Historical Introduction   Gravitational waves are ripples in spacetime that propagate at the speed of light. They are a direct consequence of Albert Einstein‚Äôs theory of general relativity, formulated in 1915 in two foundational papers:     ‚ÄúOn the General Theory of Relativity‚Äù   ‚ÄúThe Field Equations of Gravitation‚Äù   The first publication explicitly describing gravitational waves‚Äî‚Äú√úber Gravitationswellen‚Äù (1918)‚Äîappeared three years later.     Abstract of the original 1918 article by Albert Einstein   In 1974, Russell Hulse and Joseph Taylor discovered the binary pulsar PSR B1913+16‚Äîtwo orbiting stellar remnants, one of which is a pulsar emitting regular light pulses. In 1979, after four years of observation, they demonstrated that the orbital decay of the system matched the predictions of general relativity, thus confirming the existence of gravitational waves indirectly (1979 publication). They were awarded the Nobel Prize in 1993.  A 2016 update to this work is available here.     Orbital decay of the binary pulsar system. Red points are measurements, closely matching the theoretical curve predicted by general relativity.   The first direct detection of gravitational waves occurred in 2015‚Äîexactly 100 years after general relativity. Using the LIGO detectors, scientists observed the merger of two black holes (29 and 36 solar masses).  (Original paper)   In 2017, the Virgo detector in Europe joined the LIGO network, enabling triangulation of gravitational wave sources. On August 17, 2017, the network observed the merger of two neutron stars, simultaneously with electromagnetic signals, marking the beginning of multi-messenger astronomy.     Detection paper   Multi-messenger analysis   The foundational detection (GW150914) was recognized with the 2017 Nobel Prize in Physics.   As of 2025, the global network includes four detectors: two in the U.S. (LIGO), one in Italy (Virgo), and one in Japan (KAGRA). Together, they have recorded over 100 black hole mergers, enriching our understanding of the universe‚Äôs structure and evolution.     Ground-Based Gravitational Wave Detectors   At the time of writing, four operational ground-based interferometers exist:      LIGO Livingston and LIGO Hanford (USA) ‚Äì each with 4 km-long arms   Virgo (Italy) ‚Äì 3 km-long arms   KAGRA (Japan) ‚Äì a 3 km-long underground interferometer      How These Detectors Work   Gravitational waves slightly stretch and squeeze spacetime. On Earth, this is measured using giant Michelson interferometers with kilometer-scale arms. The principle involves detecting phase shifts in laser beams bouncing between mirrors at the ends of the arms. A passing wave causes a tiny differential change in path length, producing interference patterns that can be measured.                 Click the image to watch the explicative video on YouTube    Operating Point of an Interferometer   Interferometers are tuned to operate on a dark fringe, meaning destructive interference cancels the signal at the output. This requires real-time feedback control of mirror positions to maintain stability.  In this section, I present my research on modeling and simulating these feedback control loops to keep the interferometer at its operating point.     The Future of Ground-Based Detectors   Two major next-generation projects are currently underway:   üá∫üá∏ Cosmic Explorer (USA)   The Cosmic Explorer collaboration proposes building two new interferometers with arm lengths of 20 to 40 km, dramatically improving sensitivity. This would allow detection of nearly all compact binary mergers in the observable universe.  üîó Cosmic Explorer website  üñºÔ∏è Insert CE image here   üá™üá∫ Einstein Telescope (Europe)   Europe is preparing the Einstein Telescope (ET), possibly built at one or two sites. Multiple design and location options are still under study.  My work explores the scientific impact of design choices on compact binary detection rates and broader scientific potential.     ET official site   Design impact study (2023)   ET Blue Book (2025)     Pulsar Timing Arrays   Another method of detecting gravitational waves is by monitoring millisecond pulsars. These highly regular signals can exhibit arrival time delays if spacetime is distorted by a passing gravitational wave. By comparing dozens of pulsars, it‚Äôs possible to reveal such distortions.   In June 2023, the NANOGrav collaboration announced evidence of a gravitational wave background, possibly generated by supermassive black hole binaries or a population of such systems.  üîó NANOGrav discovery paper     Space-Based Interferometers   LISA (Laser Interferometer Space Antenna) is an ambitious project led by ESA in collaboration with NASA.  It will consist of three spacecraft placed in a triangle formation orbiting around the Lagrange Point L2, with arms stretching 2.5 million kilometers. This enables exploration of low-frequency gravitational waves, inaccessible from the ground.     Would you like this content broken into multiple subpages or left as one long article? I can also generate a summary or add visual elements if needed.   ","url": "http://localhost:4000/Cperigois.github.io/gravitational-waves/"
  },{
    "title": "Black holes & gravitational waves",
    "excerpt":"To introduce my research work, I propose to integrate it into three broader popular presentations that will allow for an  evaluation of the general context of the projects I have had the pleasure of conducting throughout my career. You will find three research pages:      Gravitational waves and their detection   The origins of black holes   ??   On this first page, I introduce gravitational waves with the aim of presenting my research work and the projects I have  had the pleasure of participating in.   An historical introduction   Gravitational waves are disturbances in spacetime that propagate at the speed of light. They are a direct consequence of  Albert Einstein‚Äôs general theory of relativity and his collaborators, submitted in 1915, in the form of two main papers: ‚ÄúOn the general theory of relativity‚Äù  and ‚ÄúThe Field Equations of Gravitation‚Äù. The first publication  formalizing gravitational waves ‚Äú√úber Gravitationswellen‚Äù , came three years later.                                         *Abstract of the original article on gravitational waves in 1918 by Albert Einstein *           In 1974, Russell Hulse and Joseph Taylor discovered the binary pulsar PSR B1913+16, which is a system of two objects in orbit,  one of which is a pulsar that emits a pulse of light at regular intervals. In 1979, after four years of monitoring the  characteristics of the system, Hulse and Taylor demonstrated that the evolution of the system‚Äôs orbit perfectly reproduces  the predictions of gravitational theory for a binary system (Link to the publication. This discovery earned them a Nobel Prize in 1993. The most recent publication to date (2016) that catalogs these measurements  is freely accessible at this link:  : Last publication from 2016                                         Graph showing the decay of the binary pulsar‚Äôs period. The red points represent data points, with their uncertainties (almost invisible due to being small). The curve represents the prediction of gravitational theory           The first direct detection of gravitational waves occurred in 2015‚Äîthe 100th anniversary of general relativity. Using the LIGO detectors, scientists observed the collision of two black holes, one with 29 times the mass of the Sun and the other with 36 times the Sun‚Äôs mass.(Lien vers l‚Äôarticle)   Starting in 2017, during the second data-taking phase (O2), the European detector joined the American network, enabling signal triangulation to locate the sources of gravitational waves. On August 17, 2017, the new network observed a merger of two neutron stars  simultaneously with electromagnetic waves.(Lien vers la publication,  Lien vers l‚Äôarticle de la d√©tection multimessag√®re. This marked the birth of multimessenger astronomy‚Äîthe creation of an interdisciplinary community enabling the observation of astrophysical phenomena through different cosmic messengers: electromagnetic waves, cosmic rays, neutrinos, and gravitational waves.   Also in 2017, the groundbreaking work behind the first detection, GW150914, was honored with a Nobel Prize.   As of this writing (2025), the gravitational-wave detector network comprises four instruments: two in the U.S., one in Italy, and one in Japan. The scientific community has now recorded over a hundred black hole mergers, providing astrophysicists with invaluable data on the history and evolution of the universe.   Les d√©tecteurs terrestres d‚Äôonde gravitationnels   insertion worldmap   A l‚Äôecriture de ce site il existe 4 d√©tecteurs d‚Äôondes gravitationnelles sur terre deux aux √©tats unis avec des bras de 4 km de long chacun, Virgo en Italie avec des bras de 3km et KAGRA au Japon, interf√©rometre souterrain de 3 km de long.   Fonctionnement des d√©tecteurs.   La d√©tection d‚Äôondes gravitationnelles est r√©alis√©e par la mise en √©vidence d‚Äôune dilatation ou r√©traction de l‚Äôespace-temps. Sur terre, ce ph√©nom√®ne est mesur√©e avec des interf√©rometre de Michelson g√©ants dont les bras font plusieurs kilometres de long. L‚Äôobjectif de ces dispositifs est de mesurer une interf√©rence entre les faisceaux lumineux de chacun des deux bras de l‚Äôinterf√©rometre. Un √©ventuel dephasage temoignera d‚Äôune variation dans la distance parcourue par le faisceau lumineux. En mesurant ce d√©phasage en temps r√©el il est alors possible de reconstruire le la√ßage d‚Äôune onde gravitationnelle.   Video explicative du fonctionnement : https://www.youtube.com/watch?v=UA1qG7Fjc2A   Point de fonctionnement d‚Äôun interf√©rometre. En pratique l‚Äôinterf√©rometre est calibr√© sur une frange noire, de sorte que la somme des signaux reconstruit avant la mesure par la photodiode de sortie soit quasi-nulle. Cette contrainte implique un controle pr√©cis et automatique de la position des miroirs. Dans ce billet je vous pr√©sente mes travaux sur la mod√©lisation des boucles de r√©troaction qui permettent de maintenir l‚Äôinterf√©rom√®tre a son point de fonctionnement.   Les futurs d√©tecteurs terrestres   Aujourd‚Äôhui il y a deux projets majeurs de construction de nouveaux instruments sur terre. Une collaboration etat unienne Cosmic explorer, envisage de construire deux nouveaux interf√©rometres, de 20 et/ou 40 km de longueurs de bras. Cet allongement des bras permettra d‚Äôavoir une meilleure sensibilit√© et d‚Äôobserver la quasi totalit√© des fusion d‚Äôobjets compact de l‚Äôunivers. Lien vers la page de CE : https://cosmicexplorer.org/index.html  Nom de la photo pour CE donuts truc   La communaut√© europ√©ene pr√©pare √©galement la construction d‚Äôun (ou deux) instruments de mesures. Plusieurs design sont encore envisag√© et plusieurs localisation. Dans ce billet je reprend l‚Äôetude d‚Äôimpact de design sur la detection de systeme binaire d‚Äôobjetc compacts et les grand enjeux scientifiques de cettre nouvelle g√©n√©ration de d√©tecteurs. lien vers le site ET : https://www.einsteintelescope-emr.eu/fr/   Etude d‚Äôimpact des design : https://ui.adsabs.harvard.edu/abs/2023JCAP‚Ä¶07..068B/abstract Blue book : https://ui.adsabs.harvard.edu/abs/2025arXiv250312263A/abstract   Les r√©seaux de pulsars   Il existe une seconde m√©thode pour observer les ondes gravitationnelles qui consiste a surveiller des pulsar milliseconde avec les t√©lescope terrestre. Ces pulsars envoie des pulses lumineux parfaitement r√©gulier, dont l‚Äô√©ventuel retard d‚Äôarriv√©e t√©moigne du passage d‚Äôune onde gravitationnelle. En comparant les temps d‚Äôarriv√©e des pulses de plusieurs dizaines de pulsars, il est possible de mettre en √©vidence le passage d‚Äôune onde gravitationnelle. En juin 2023, la collaboration Nanograv annonce l‚Äôobservation d‚Äôun fond gravitationnel dont l‚Äôorigine fait d√©bat. Les hypoth√®ses privil√©gi√©s proposent des ondes √©misent par une binaire de trous noirs supermassif, ou une population de ces binaires, dont les ondes gravitationnelles se superposeraient. Lien vers la publication de NAnograv : https://ui.adsabs.harvard.edu/abs/2023ApJ‚Ä¶951L‚Ä¶9A/abstract   Les interf√©rom√®tres spatiaux   LISA est le projet Europ√©en de l‚ÄôESA (European space agency) en collaboration avec la NASA. L‚Äôinstrument sera compos√© de trois modules dispos√©s en triangle autour d‚Äôun point de lagrange L2? Ces instruments seront √©loign√©s de 2.5 millions de kilom√®tres, et permettent d‚Äôexplorer une nouvelle plage de fr√©quence pour les ondes gravitationnelles.   ","url": "http://localhost:4000/Cperigois.github.io/gravitational-waves/old"
  },{
    "title": {"en":"Data science","fr":"Data science"},
    "excerpt":"Projets en cours                                                                                                                       Princess                                                    Outil open source pour pr√©dire les ondes gravitationnelles √† partir de mod√®les astrophysiques.                                                   En savoir plus                                                                                                                                                    D√©tection de plantations de palmiers                                                    Algorithme de deep learning pour identifier les plantations d‚Äôhuile de palme sur images satellites. En d√©veloppement.                                                   En savoir plus                                                                                                                                                    Cours d'initiation √† Python                                                    Des bases du langage Python jusqu‚Äô√† l‚Äôarchitecture logicielle avanc√©e                                                   En savoir plus                                       ","url": "http://localhost:4000/Cperigois.github.io/"
  },{
    "title": "Data science",
    "excerpt":"Current projects                                                                                                                       Princess                                                    Open source tool to predict gravitational waves from astrophysical models.                                                   Learn more                                                                                                                                                    Palm oil farms searches                                                    Deep learning algorithm to detect palm oil farms from satellite images. Under developement                                                   Learn more                                                                                                                                                    Search for anomalies in Time Series                                                    Developpement of an autoencoder to detect anomalies such as drift in sinuso√Ødal signals.                                                   Learn more                                        ","url": "http://localhost:4000/Cperigois.github.io/"
  }]
