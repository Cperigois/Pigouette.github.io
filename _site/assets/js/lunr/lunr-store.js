var store = [,{
    "title": "Beyond the Lab",
    "excerpt":"Current projects                                                                                                                       Search for anomalies in Time Series                                                    Developpement of an autoencoder to detect anomalies such as drift in sinusoïdal signals.                                                   Learn more                                                                                                                                                    Palm oil farms searches                                                    Deep learning algorithm to detect palm oil farms from satellite images. Under developement                                                   Learn more                                                                                                                                                    Lectures for python beginners                                                    From python basics to a well built architecture                                                   Learn more                                        ","url": "https://pigouette.github.io/Pigouette.github.io/BeyondTheLab/"
  },{
    "title": "Noise modelisation and propagation in gravitational wave detector",
    "excerpt":"To detect gravitational waves with maximum efficiency, interferometers must be maintained at their operating point — ideally on a dark fringe — so that any deviation (from gravitational wave signals) creates detectable interference patterns at the photodiodes. This is achieved through multiple feedback control loops that stabilize the mirror positions and the input laser frequency.   However, these control systems can also serve as channels through which instrumental noise propagates within the detector. A significant part of my PhD work involved modeling these feedback loops to better understand how noise is introduced and transferred throughout the system.   Interferometer Degrees of Freedom   The longitudinal control of the interferometer is based on four main degrees of freedom (DoF), which represent critical optical lengths in the system. These are:           CARM (Common Arm):  \\(CARM = \\frac{L_N + L_W}{2}\\) Controls the average length of the Fabry-Pérot arms using signal from photodiode B2.            DARM (Differential Arm):  \\(DARM = L_N - L_W\\) Key observable for gravitational waves, controlling the end mirror positions.            MICH (Michelson):  \\(MICH = l_N - l_W\\) Measures asymmetry in the short arms, extracted via photodiode B4.            PRCL (Power Recycling Cavity Length):  \\(PRCL = l_0 + \\frac{l_W + l_N}{2}\\) Coupled with MICH, also measured via B4, and used to stabilize the power recycling mirror (PRM).       These DoFs define the longitudinal control architecture.     Interferometer and Control Loop Modeling   The control loop simulation framework, called Noise Budget, includes all major subsystems:      Sensing (green): Converts photodiode signals into error signals for each DoF.   Mirror/Frequency Control (yellow): Converts errors into corrective signals.   Driving (orange): Simulates actual mirror actuation.   Laser (blue): Simulates laser frequency response.   Optickle (violet): Models optical response to all mirror and laser perturbations.   These modules together simulate the closed-loop noise propagation and are used to test new control strategies or predict future interferometer performance.     Study of the MICH Loop   The MICH control loop is responsible for stabilizing short-arm asymmetry.  For frequencies above 50 Hz, the loop is dominated by detection noise (electronic + shot noise).  Assuming this dominance, I was able to derive the injection transfer function ( Y(f) ) for the loop and validate the simulated model against actual interferometer data.  This confirmed the theoretical noise paths and highlighted where detection noise dominates the system.     Study of the SSFS Loop (Laser Frequency Stabilization)   The laser introduces phase noise, which is integrated from frequency fluctuations. Due to arm asymmetries (mirror reflectivity, thermal effects), this phase noise couples into the main gravitational wave signal channel.   The Second Stage Frequency Stabilization (SSFS) loop uses reflected optical signals at POP, measured via photodiode B4, to compute correction signals for the laser.   This loop is influenced by time-varying transfer functions due to thermal drifts and asymmetry fluctuations. To model this, I introduced time-dependent gains:      \\(F_{PC}(t)\\): Power Coupling Gain   \\(F_{TC}(t)\\): Transfer Coupling Gain   \\(Y(f, t)\\): Injection Transfer Function   These parameters were calibrated using broadband noise injections (( N_{inj} )) and validated at times ( t_{inj} ). The model was used to explain differences between simulated and real data in DARM.     Conclusion   The feedback control systems in the Virgo interferometer are essential for keeping the detector in its optimal operating state. By modeling the noise propagation through these loops, it’s possible to:      Identify dominant noise sources   Design more effective control strategies   Predict the sensitivity of future detectors   Through this work, I demonstrated that:      The MICH loop is dominated by detection noise above 50Hz.   The SSFS loop requires time-varying modeling due to asymmetries.   Overall, this project not only validated important theoretical models, but also highlighted remaining challenges, such as unexplained bias and underestimation of some residual noise sources.      Future work should investigate whether these mismatches originate from modeling assumptions, unmodeled loop couplings, or unknown noise mechanisms.    ","url": "https://pigouette.github.io/Pigouette.github.io/gravitational-waves/Noisebudget"
  },{
    "title": "Search for anomalies in sinusoidal signals",
    "excerpt":"                                       This study stems from a personal curiosity about the implementation of autoencoders for anomaly detection in signal processing. This type of approach is already widely documented on Papers With Code; here are a few relevant references. For me, it’s also an opportunity to get hands-on experience in a new area of deep learning: autoencoders applied to time series, a topic I already understand well from a signal analysis perspective.           The goal of this study is to test the limits of autoencoder-based anomaly detection in time-series signals. Given the breadth of the topic, I limited the study to sinusoidal signals affected by Gaussian noise and drift noise, the latter being typical of wear in electronic components.   This post consists of three sections:     A summary of how autoencoders work, with the parameters used in this study.   The “step-by-step” training strategy to address the periodic nature of the signals.   A model evaluation on noisy signals with a controlled drift ratio.     AI Model   Basics of Autoencoders   An autoencoder is a type of neural network designed to reconstruct its input after compressing it into a lower-dimensional latent space. It has two parts:      The encoder: reduces the input dimensionality to extract its essential features.   The decoder: reconstructs the input from the compressed representation.   In unsupervised learning, an autoencoder can learn dominant patterns in the data. Any significant reconstruction error then indicates an anomaly (i.e., data that deviates from the learned patterns).   The standard loss function is the Mean Squared Error:   \\[\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\hat{x}_i)^2\\]  where \\(x_i\\) is the original data and \\(\\hat{x}_i\\) is its reconstruction.     My Model   The model used in this study is a 1D convolutional autoencoder designed for fixed-length time signals (500 samples). It consists of two main blocks: an encoder and a decoder, built from convolutional layers suited to time-structured data.   Encoder   The encoder transforms the input signal into a low-dimensional latent representation. It includes:   Three successive 1D convolutional layers with:      Increasing numbers of channels (16, 32, then 64),   A kernel size of 5,   A stride of 2 to progressively reduce temporal resolution,   A ReLU activation after each convolution.   The output is then flattened into a linear vector and passed through a fully connected layer to produce a latent embedding of predefined size (encoded_size).   Decoder   The decoder reconstructs the original signal from the latent representation. It mirrors the encoder:      A first fully connected layer reshapes the latent vector into a tensor suitable for the transposed convolutional layers.   Three transposed convolution layers:            They progressively increase the temporal resolution,       Reduce the number of channels from 64 → 32 → 16 → 1 (the original shape),       Each step is followed by a ReLU activation, except the last.           This architecture allows the model to learn to extract key features from the input signal and reconstruct them as faithfully as possible. Latent compression forces the autoencoder to filter noise and retain only essential information.   This model encodes 500-sample input signals into a latent space sized at 30% of the input, and reconstructs them via transposed convolutions. The architecture is intentionally compact to facilitate progressive learning of simple patterns.     Model Training   Training Data   Training is conducted on batches of 12,000 signals, each 500 samples long, fed in mini-batches of 32 to the GPU. Each signal is a noisy sinusoid, randomly generated according to the parameters defined for each training phase.     Step-by-Step Training Strategy   Training progresses through increasingly complex signal generations. The summary table is as follows:                  Step       Epochs       Amplitude       Phase       Frequency (Hz)       Noise                       1       10       4       0       0.05       None                 2       30       \\(\\mathcal{U}(3.5, 4.5)\\)       0       0.05       None                 3       30       \\(\\mathcal{U}(3.5, 4.5)\\)       \\(\\mathcal{U}(0, 0.5)\\)       0.05       None                 4       100       \\(\\mathcal{U}(3.5, 4.5)\\)       \\(\\mathcal{U}(0, 0.5)\\)       \\(\\mathcal{U}(0.025, 0.075)\\)       None                 5       100       \\(\\mathcal{U}(3.5, 4.5)\\)       \\(\\mathcal{U}(0, 0.5)\\)       \\(\\mathcal{U}(0.025, 0.075)\\)       \\(\\mathcal{N}(0, 0.05)\\)                 6       250       \\(\\mathcal{U}(2, 6)\\)       \\(\\mathcal{U}(0, 2π)\\)       \\(\\mathcal{U}(0.025, 0.225)\\)       \\(\\mathcal{N}(0, 0.05)\\)                 7       400       \\(\\mathcal{U}(2, 6)\\)       \\(\\mathcal{U}(0, 2π)\\)       \\(\\mathcal{U}(0.025, 0.225)\\)       \\(\\mathcal{N}(0, 0.25)\\)           A ReduceLROnPlateau scheduler dynamically adjusts the learning rate from an initial value of ( 10^{-4} ), if validation loss plateaus.     Residual Noise   Due to the random nature of the added noise, perfect signal reconstruction is impossible. The final loss therefore stabilizes to a non-zero residual noise.   Assuming:   \\[\\text{signal}_{\\text{target}} = \\text{informative\\_signal} + \\text{random\\_noise}\\]  and perfect reconstruction of the informative part, the MSE becomes:   \\[\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n [(\\text{output} - \\text{target})^2] = \\frac{1}{n} \\sum_{i=1}^n [\\text{random\\_noise}^2]\\]  In this study:     Steps 4–6: residual noise ≈ 0.0025   Step 7: residual noise ≈ 0.0625      Blue : Validation loss evolution across the different training steps described on the previous table. Red : Learning rate evolution across the training. The grey zone represents the theoretical limits the model cannot overtake.     Evaluation and Testing on Noisy Signals   Model Evaluation   The model is evaluated on 10,000 new signals generated with the parameters of Step 7.  Observed median loss:   \\[\\text{MSE}_{\\text{test}} = 0.078^{+0.053}_{-0.012}\\]  This is compatible with residual noise, indicating good generalization capacity.     Drift Noise   A drift component was added to the signals:      Drift is a slow and continuous signal shift over time. It can be modeled with an affine function:    \\[\\text{drift}(t) = \\alpha \\cdot t\\]  where \\(\\alpha\\) is the drift coefficient.     Examples of drifted signals and their reconstruction for various values of \\(\\alpha\\).     Anomaly Detection   The model fails to reconstruct signals containing unseen drift, as expected. For each drift ratio, the loss is compared to evaluation percentiles:      OK: MSE &lt; 95ᵗʰ percentile   WARNING: 95ᵗʰ percentile &lt; MSE &lt; max   ANOMALY: MSE &gt; max (evaluation)   To quantify detection threshold, we define the noise ratio:   \\[\\text{Noise ratio} = \\frac{\\text{total\\_drift}}{\\text{residual\\_error}}\\]  The model detects anomalies as soon as the noise ratio reaches 1.6, which shows high sensitivity. This could be improved by increasing signal length.      Performance for drift signal reconstitution for various values of \\(\\alpha\\).     Conclusion   Autoencoders prove effective for detecting anomalies in sinusoidal signals contaminated by Gaussian noise and drift. The method is particularly sensitive to gradual deviations, as long as their amplitude exceeds the residual noise.   Next steps:     Use longer signals to detect subtler drift.   Explore other waveform types: triangular signals, Heaviside functions, etc.   Test the hypothesis that training difficulties stem from the zero-mean nature of sinusoids — e.g., by adding an offset.   This project is a proof-of-concept on simulated data. It would be relevant to test this approach on real-world data to assess its industrial potential.    ","url": "https://pigouette.github.io/Pigouette.github.io/BeyondTheLab/AILab/Search_anomaly"
  },{
    "title": "All projects",
    "excerpt":"A list of all projects presented on this website. Projects tagged as “independent” are self-initiated,  driven by curiosity, and developed as part of my self-learning journey.   My projects                                  Noise modelisation and propagation in gravitational wave detector                                                                                                                                              Statistics                                           Regression                                           Frequency-Spectrum                                           Time-Series                                           Matlab                                           Simulink                                           Modeling                                           PhD                                                      Study and modelisation of noise propagation through control loops in the Virgo detector                                              Search for anomalies in sinusoidal signals                                                                                                                                              Autoencodeur                                           CNN                                           Simulation                                           Time-Series                                           Python                                           PyTorch                                           Modeling                                           Independent Study                                                      Proof of concept (PoC) demonstrating the efficiency of autoencoders for anomaly detection in time series signals.                                                                                                                   ","url": "https://pigouette.github.io/Pigouette.github.io/all-projects/"
  },{
    "title": "Black Holes & Gravitational Waves",
    "excerpt":"To introduce my research work, I present it through three broader, popular-science-oriented sections. These allow a general contextualization of the scientific projects I have had the pleasure of conducting throughout my career. You will find three main topics:      Gravitational waves and their detection   The origin of black holes   (Upcoming content)   This first page is dedicated to gravitational waves, offering an overview of the field and introducing my related research projects.     A Brief Historical Introduction   Gravitational waves are ripples in spacetime that propagate at the speed of light. They are a direct consequence of Albert Einstein’s theory of general relativity, formulated in 1915 in two foundational papers:     “On the General Theory of Relativity”   “The Field Equations of Gravitation”   The first publication explicitly describing gravitational waves—“Über Gravitationswellen” (1918)—appeared three years later.     Abstract of the original 1918 article by Albert Einstein   In 1974, Russell Hulse and Joseph Taylor discovered the binary pulsar PSR B1913+16—two orbiting stellar remnants, one of which is a pulsar emitting regular light pulses. In 1979, after four years of observation, they demonstrated that the orbital decay of the system matched the predictions of general relativity, thus confirming the existence of gravitational waves indirectly (1979 publication). They were awarded the Nobel Prize in 1993.  A 2016 update to this work is available here.     Orbital decay of the binary pulsar system. Red points are measurements, closely matching the theoretical curve predicted by general relativity.   The first direct detection of gravitational waves occurred in 2015—exactly 100 years after general relativity. Using the LIGO detectors, scientists observed the merger of two black holes (29 and 36 solar masses).  (Original paper)   In 2017, the Virgo detector in Europe joined the LIGO network, enabling triangulation of gravitational wave sources. On August 17, 2017, the network observed the merger of two neutron stars, simultaneously with electromagnetic signals, marking the beginning of multi-messenger astronomy.     Detection paper   Multi-messenger analysis   The foundational detection (GW150914) was recognized with the 2017 Nobel Prize in Physics.   As of 2025, the global network includes four detectors: two in the U.S. (LIGO), one in Italy (Virgo), and one in Japan (KAGRA). Together, they have recorded over 100 black hole mergers, enriching our understanding of the universe’s structure and evolution.     Ground-Based Gravitational Wave Detectors   At the time of writing, four operational ground-based interferometers exist:      LIGO Livingston and LIGO Hanford (USA) – each with 4 km-long arms   Virgo (Italy) – 3 km-long arms   KAGRA (Japan) – a 3 km-long underground interferometer      How These Detectors Work   Gravitational waves slightly stretch and squeeze spacetime. On Earth, this is measured using giant Michelson interferometers with kilometer-scale arms. The principle involves detecting phase shifts in laser beams bouncing between mirrors at the ends of the arms. A passing wave causes a tiny differential change in path length, producing interference patterns that can be measured.                 Click the image to watch the explicative video on YouTube    Operating Point of an Interferometer   Interferometers are tuned to operate on a dark fringe, meaning destructive interference cancels the signal at the output. This requires real-time feedback control of mirror positions to maintain stability.  In this section, I present my research on modeling and simulating these feedback control loops to keep the interferometer at its operating point.     The Future of Ground-Based Detectors   Two major next-generation projects are currently underway:   🇺🇸 Cosmic Explorer (USA)   The Cosmic Explorer collaboration proposes building two new interferometers with arm lengths of 20 to 40 km, dramatically improving sensitivity. This would allow detection of nearly all compact binary mergers in the observable universe.  🔗 Cosmic Explorer website  🖼️ Insert CE image here   🇪🇺 Einstein Telescope (Europe)   Europe is preparing the Einstein Telescope (ET), possibly built at one or two sites. Multiple design and location options are still under study.  My work explores the scientific impact of design choices on compact binary detection rates and broader scientific potential.     ET official site   Design impact study (2023)   ET Blue Book (2025)     Pulsar Timing Arrays   Another method of detecting gravitational waves is by monitoring millisecond pulsars. These highly regular signals can exhibit arrival time delays if spacetime is distorted by a passing gravitational wave. By comparing dozens of pulsars, it’s possible to reveal such distortions.   In June 2023, the NANOGrav collaboration announced evidence of a gravitational wave background, possibly generated by supermassive black hole binaries or a population of such systems.  🔗 NANOGrav discovery paper     Space-Based Interferometers   LISA (Laser Interferometer Space Antenna) is an ambitious project led by ESA in collaboration with NASA.  It will consist of three spacecraft placed in a triangle formation orbiting around the Lagrange Point L2, with arms stretching 2.5 million kilometers. This enables exploration of low-frequency gravitational waves, inaccessible from the ground.     Would you like this content broken into multiple subpages or left as one long article? I can also generate a summary or add visual elements if needed.   ","url": "https://pigouette.github.io/Pigouette.github.io/gravitational-waves/"
  },{
    "title": "Data science",
    "excerpt":"Current projects                                                                                                                       Princess                                                    Open source tool to predict gravitational waves from astrophysical models.                                                   Learn more                                                                                                                                                    Palm oil farms searches                                                    Deep learning algorithm to detect palm oil farms from satellite images. Under developement                                                   Learn more                                                                                                                                                    Search for anomalies in Time Series                                                    Developpement of an autoencoder to detect anomalies such as drift in sinusoïdal signals.                                                   Learn more                                        ","url": "https://pigouette.github.io/Pigouette.github.io/"
  }]
